<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><span class='hs-varop'>&gt;</span> <span class='hs-comment'>{-# LANGUAGE MagicHash,ScopedTypeVariables #-}</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Main</span> <span class='hs-keyword'>where</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Java</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Pipes</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span><span class='hs-varid'>forever</span><span class='hs-layout'>,</span><span class='hs-varid'>replicateM_</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Pipes</span><span class='hs-varop'>.</span><span class='hs-conid'>Prelude</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>P</span>  <span class='hs-comment'>-- Pipes.Prelude provides 'take', too</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>System</span><span class='hs-varop'>.</span><span class='hs-conid'>IO</span>
</pre>

```
Foreign Export
--------------
We will be looking at Pipes. A coroutine library in Eta/Haskell.

Pre-requisites:
A basic understanding of Monad Transformer.

Pipes give you:
- Effects
- Streaming
- Composability



The basic Pipe type transformer is a Trampoline.
```

```haskell
newtype Trampoline m r =
  Trampoline {bounce :: m (Either (Trampoline m r) r)}

pause :: Monad m => Trampoline m ()

run :: Monad m => Trampoline m r -> m r

Lets look at a simple example.
```


```
To enforce loose coupling, components can only communicate using two commands:

yield: Send output data
await: Receive input data



pipes has four types of components built around these two commands:

Producers can only yield values and they model streaming sources
Consumers can only await values and they model streaming sinks
Pipes can both yield and await values and they model stream transformations
Effects can neither yield nor await and they model non-streaming components
You can connect these components together in four separate ways which parallel the four above types:

for handles yields
(>~) handles awaits
(>->) handles both yields and awaits
(>>=) handles return values
```


```haskell
Lets look at their types:

Producers
---------
yield :: Monad m => a -> Producer a m ()

data X  -- The uninhabited type

type Effect m r = Producer X m r

for :: Monad m => Producer a m r -> (a -> Effect m ()) -> Effect m r

(~>) :: Monad m
      => (a -> Producer b m ())
      -> (b -> Producer c m ())
      -> (a -> Producer c m ())


Consumers
---------
await :: Monad m => Consumer a m a

(>~) :: Monad m => Effect m b -> Consumer b m c -> Effect m c


Pipes
-----
(>->) :: Monad m => Producer a m r -> Consumer a m r -> Effect m r

A Pipe is a monad transformer that is a mix between a Producer and Consumer, because a Pipe can both await and yield.

Pipe a a m r

The types are much much more general.

(>->) :: Monad m => Producer a m r -> Pipe   a b m r -> Producer b m r
(>->) :: Monad m => Pipe   a b m r -> Consumer b m r -> Consumer a m r
(>->) :: Monad m => Pipe   a b m r -> Pipe   b c m r -> Pipe   a c m r


cat :: Monad m => Pipe a a m r
cat = forever $ do
    x <- await
    yield x

cat and >-> form a Category


```


<pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>take</span> <span class='hs-keyglyph'>::</span>  <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Pipe</span> <span class='hs-varid'>a</span> <span class='hs-varid'>a</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>take</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-varid'>replicateM_</span> <span class='hs-varid'>n</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>await</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>yield</span> <span class='hs-varid'>x</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-varid'>lift</span> <span class='hs-varop'>$</span> <span class='hs-varid'>putStrLn</span> <span class='hs-str'>"You shall not pass!"</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>maxInput</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Producer</span> <span class='hs-conid'>String</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>maxInput</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>P</span><span class='hs-varop'>.</span><span class='hs-varid'>stdinLn</span> <span class='hs-varop'>&gt;-&gt;</span> <span class='hs-conid'>Main</span><span class='hs-varop'>.</span><span class='hs-varid'>take</span> <span class='hs-varid'>n</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>head</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Pipe</span> <span class='hs-varid'>a</span> <span class='hs-varid'>a</span> <span class='hs-varid'>m</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>head</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>P</span><span class='hs-varop'>.</span><span class='hs-varid'>take</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>main</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>main</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>hSetBuffering</span> <span class='hs-varid'>stdin</span> <span class='hs-conid'>LineBuffering</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>hSetBuffering</span> <span class='hs-varid'>stdout</span> <span class='hs-conid'>LineBuffering</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>runEffect</span> <span class='hs-varop'>$</span> <span class='hs-varid'>maxInput</span> <span class='hs-num'>3</span> <span class='hs-varop'>&gt;-&gt;</span> <span class='hs-conid'>P</span><span class='hs-varop'>.</span><span class='hs-varid'>stdoutLn</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- runEffect $ P.stdinLn &gt;-&gt; head 3 &gt;-&gt; P.stdoutLn</span>
</pre>

```
Lets export some of these now:
```

<pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>data</span> <span class='hs-comment'>{-# CLASS "Main" #-}</span> <span class='hs-conid'>Main</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Main</span> <span class='hs-layout'>(</span><span class='hs-conid'>Object</span><span class='hs-cpp'>#</span> <span class='hs-conid'>Main</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Class</span>
</pre>
<pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>foreign</span> <span class='hs-varid'>export</span> <span class='hs-varid'>java</span> <span class='hs-str'>"@static com.typelead.Util.test"</span> <span class='hs-varid'>main</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
</pre></body>
</html>
