<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="hscolour.css" type="text/css" />
</head>
<body>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ --><title>Haskell code</title><link type='text/css' rel='stylesheet' href='hscolour.css' /></head><body><pre><span class='hs-varop'>&gt;</span> <span class='hs-comment'>{-# LANGUAGE MagicHash,ScopedTypeVariables #-}</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Main</span> <span class='hs-keyword'>where</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Java</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Pipes</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span><span class='hs-varid'>forever</span><span class='hs-layout'>,</span><span class='hs-varid'>replicateM_</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Pipes</span><span class='hs-varop'>.</span><span class='hs-conid'>Prelude</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>P</span>  <span class='hs-comment'>-- Pipes.Prelude provides 'take', too</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span><span class='hs-layout'>)</span>
<span class='hs-varop'>&gt;</span> <span class='hs-keyword'>import</span> <span class='hs-conid'>System</span><span class='hs-varop'>.</span><span class='hs-conid'>IO</span>
</pre><pre><code>Foreign Export
--------------
We will be looking at Pipes. A coroutine library in Eta/Haskell.

Pre-requisites:
A basic understanding of Monad Transformer.


If you sacrifice Effects you get Haskell&#39;s pure and lazy lists, which you can transform using composable
functions in constant space, but without interleaving effects.

If you sacrifice Streaming you get mapM, forM and &quot;ListT done wrong&quot;, which are composable and effectful,
but do not return a single result until the whole list has first been processed and loaded into memory.

If you sacrifice Composability you write a tightly coupled read, transform, and write loop in IO, which is
streaming and effectful, but is not modular or separable.


Pipes give you:
- Effects
- Streaming
- Composability



The basic Pipe type transformer is a Trampoline.</code></pre><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Trampoline</span> m r <span class="fu">=</span>
  <span class="dt">Trampoline</span> {<span class="ot">bounce ::</span> m (<span class="dt">Either</span> (<span class="dt">Trampoline</span> m r) r)}

<span class="ot">pause ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Trampoline</span> m ()

<span class="ot">run ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Trampoline</span> m r <span class="ot">-&gt;</span> m r

<span class="dt">Lets</span> look at a simple example<span class="fu">.</span></code></pre></div><pre><code>To enforce loose coupling, components can only communicate using two commands:

yield: Send output data
await: Receive input data



pipes has four types of components built around these two commands:

Producers can only yield values and they model streaming sources
Consumers can only await values and they model streaming sinks
Pipes can both yield and await values and they model stream transformations
Effects can neither yield nor await and they model non-streaming components
You can connect these components together in four separate ways which parallel the four above types:

for handles yields
(&gt;~) handles awaits
(&gt;-&gt;) handles both yields and awaits
(&gt;&gt;=) handles return values</code></pre><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Lets</span> look at their types<span class="fu">:</span>

<span class="dt">Producers</span>
<span class="co">---------</span>
<span class="ot">yield ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Producer</span> a m ()

<span class="kw">data</span> <span class="dt">X</span>  <span class="co">-- The uninhabited type</span>

<span class="kw">type</span> <span class="dt">Effect</span> m r <span class="fu">=</span> <span class="dt">Producer</span> <span class="dt">X</span> m r

<span class="ot">for ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Producer</span> a m r <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Effect</span> m ()) <span class="ot">-&gt;</span> <span class="dt">Effect</span> m r

<span class="ot">(~&gt;) ::</span> <span class="dt">Monad</span> m
      <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Producer</span> b m ())
      <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> <span class="dt">Producer</span> c m ())
      <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Producer</span> c m ())


<span class="dt">Consumers</span>
<span class="co">---------</span>
<span class="ot">await ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Consumer</span> a m a

<span class="ot">(&gt;~) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Effect</span> m b <span class="ot">-&gt;</span> <span class="dt">Consumer</span> b m c <span class="ot">-&gt;</span> <span class="dt">Effect</span> m c


<span class="dt">Pipes</span>
<span class="co">-----</span>
<span class="ot">(&gt;-&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Producer</span> a m r <span class="ot">-&gt;</span> <span class="dt">Consumer</span> a m r <span class="ot">-&gt;</span> <span class="dt">Effect</span> m r

<span class="dt">A</span> <span class="dt">Pipe</span> is a monad transformer that is a mix between a <span class="dt">Producer</span> and <span class="dt">Consumer</span>, because a <span class="dt">Pipe</span> can both await and yield<span class="fu">.</span>

<span class="dt">Pipe</span> a a m r

<span class="dt">The</span> types are much much more general<span class="fu">.</span>

<span class="ot">(&gt;-&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Producer</span> a m r <span class="ot">-&gt;</span> <span class="dt">Pipe</span>   a b m r <span class="ot">-&gt;</span> <span class="dt">Producer</span> b m r
<span class="ot">(&gt;-&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Pipe</span>   a b m r <span class="ot">-&gt;</span> <span class="dt">Consumer</span> b m r <span class="ot">-&gt;</span> <span class="dt">Consumer</span> a m r
<span class="ot">(&gt;-&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Pipe</span>   a b m r <span class="ot">-&gt;</span> <span class="dt">Pipe</span>   b c m r <span class="ot">-&gt;</span> <span class="dt">Pipe</span>   a c m r


<span class="ot">cat ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Pipe</span> a a m r
cat <span class="fu">=</span> forever <span class="fu">$</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> await
    yield x

cat and <span class="fu">&gt;-&gt;</span> form a <span class="dt">Category</span>
</code></pre></div><pre><span class='hs-varop'>&gt;</span> <span class='hs-definition'>take</span> <span class='hs-keyglyph'>::</span>  <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Pipe</span> <span class='hs-varid'>a</span> <span class='hs-varid'>a</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>take</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-varid'>replicateM_</span> <span class='hs-varid'>n</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>x</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>await</span>
<span class='hs-varop'>&gt;</span>         <span class='hs-varid'>yield</span> <span class='hs-varid'>x</span>
<span class='hs-varop'>&gt;</span>     <span class='hs-varid'>lift</span> <span class='hs-varop'>$</span> <span class='hs-varid'>putStrLn</span> <span class='hs-str'>"You shall not pass!"</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>maxInput</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Producer</span> <span class='hs-conid'>String</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>maxInput</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>P</span><span class='hs-varop'>.</span><span class='hs-varid'>stdinLn</span> <span class='hs-varop'>&gt;-&gt;</span> <span class='hs-conid'>Main</span><span class='hs-varop'>.</span><span class='hs-varid'>take</span> <span class='hs-varid'>n</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>head</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Pipe</span> <span class='hs-varid'>a</span> <span class='hs-varid'>a</span> <span class='hs-varid'>m</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>head</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>P</span><span class='hs-varop'>.</span><span class='hs-varid'>take</span>
<span class='hs-varop'>&gt;</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>main</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<span class='hs-varop'>&gt;</span> <span class='hs-definition'>main</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>hSetBuffering</span> <span class='hs-varid'>stdin</span> <span class='hs-conid'>LineBuffering</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>hSetBuffering</span> <span class='hs-varid'>stdout</span> <span class='hs-conid'>LineBuffering</span>
<span class='hs-varop'>&gt;</span>   <span class='hs-varid'>runEffect</span> <span class='hs-varop'>$</span> <span class='hs-varid'>maxInput</span> <span class='hs-num'>3</span> <span class='hs-varop'>&gt;-&gt;</span> <span class='hs-conid'>P</span><span class='hs-varop'>.</span><span class='hs-varid'>stdoutLn</span>
<span class='hs-varop'>&gt;</span> <span class='hs-comment'>-- runEffect $ P.stdinLn &gt;-&gt; head 3 &gt;-&gt; P.stdoutLn</span>
</pre><pre><code>Lets export some of these now:</code></pre><pre><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>foreign</span> <span class='hs-varid'>export</span> <span class='hs-varid'>java</span> <span class='hs-str'>"@static com.typelead.Util.test"</span> <span class='hs-varid'>main</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
</pre></body></html>
</body>
</html>
